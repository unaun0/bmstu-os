# Анализ

## Обработка через создание нового процесса (fork)

При каждом новом клиенте создаётся новый процесс - затратная операция, так как процесс получает собственное адресное пространство, создаётся новая таблица страниц, копируются дескрипторы и т. д.

Переключение между процессами тоже дороже, чем между потоками.

Среднее время обработки выше из-за накладных расходов на создание процессов.

**Самый медленный вариант при высокой нагрузке.**

## Обработка через создание нового потока (pthread)

Потоки легче, чем процессы, так как используют общее адресное пространство и не требуют отдельной таблицы страниц.

Создание потока быстрее, чем создание процесса. Переключение между потоками проще, чем между процессами.

Однако, если потоков слишком много, возникнут проблемы с переключением контекста и потреблением памяти (стек каждого потока).

**Среднее время обработки ниже, чем у процессов, но может страдать при очень большом количестве клиентов из-за overhead потокового управления.**

## Обработка через мультиплексоры (epoll, select, kqueue)

Использует один (или несколько) поток для обработки множества клиентов без создания новых потоков или процессов.

Реакция на события (готовность к чтению/записи) происходит через механизм неблокирующего ввода-вывода (I/O multiplexing).

Подходит для серверов с высокой нагрузкой, так как не требует создания дополнительных процессов/потоков.

Среднее время обработки минимально, так как нет затрат на создание новых процессов/потоков.


## Вывод

* Самый медленный → Процессы (fork), так как создание процесса дорого.
* Средний вариант → Потоки (threads), быстрее процессов, но при перегрузке могут тормозить.
* Самый быстрый → Мультиплексоры (epoll, select, kqueue), так как не создают новые потоки/процессы.