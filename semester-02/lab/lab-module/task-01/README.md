# Загружаемые модули ядра

- должны содержать два макроса `module_init` и `module_exit`.

## Макрос `module_init`

- cлужит для регистрации функции при инициализации модуля. 
- принимает имя функции в качестве фактического параметра.
- будет вызываться, при загрузке модуля в ядро. 
- передаваемая функция должна соответствовать следующему прототипу:

```
int func_init(void);
```

- если функция инициализации завершилась успешно, то возвращается значение ноль. 
- в случае ошибки возвращается ненулевое значение.

Если функция не передается в макрос, то код, который необходимо выполнить при загрузке модуля может быть написан в самом макросе.

Определение макроса module_init:
```
#define __initcall(fn) static initcall_t __initcall_##fn __init_call = fn
#define __init_call __attribute__ ((unused,__section__ ("function_ptrs")))
#define module_init(x) __initcall(x);
```

## Макрос `module_exit`

- служит для регистрации функции, которая вызывается при удалении модуля из ядра.
- эта функция выполняет задачу освобождения ресурсов. 
- после завершения функции модуль выгружается.
- функция завершения должна соответствовать прототипу:

```
void func_exit(void);
```

## Пример простого загружаемого модуля ядра

```
static int __init md_init( void ) {
    printk( "Module md loaded!\n" );
    return 0;
}
static void __exit md_exit( void ) {
    printk( "Module unloaded!\n" );
}
module_init( md_init );
module_exit( md_exit );
```

## Уровни протоколирования

- восемь уровней протоколирования, показанных в таблице.
- все константы определены в файле `linux/kernel.h`.

| **Уровень** | **Константа** | **Описание** |
|:-:|:-|:-|
| 7 | KERN_DEBUG | Отладочные сообщения, самый низкий приоритет |
| 6 | KERN_INFO | Информационные сообщения |
| 5 | KERN_NOTICE | Это уже не информационное сообщение, но еще и не предупреждение |
| 4 | KERN_WARNING | Предупреждение: скоро может пойти что-то не так |
| 3 | KERN_ERR | Возникла ошибка |
| 2 | KERN_CRIT | Возникла критическая ошибка |
| 1 | KERN_ALERT | Тревога — система скоро "развалится" |
| 0 | KERN_EMERG | Система "развалилась" (система больше не может использоваться)|

## Макросы для установки информации о модуле

Макросы `MODULE_LICENSE`, `MODULE_AUTHOR`, `MODULE_DESCRIPTION`,
`MODULE_SUPPORTED_DEVICE`, `MODULE_VERSION` — это макросы, которые
"дают" linux информацию о модуле, которую потом можно получить с помощью
команды `modinfo`. 

### Макрос `MODULE_LICENSE`

- используется для того, чтобы сообщить ядру, под какой лицензией распространяется исходный код модуля, что влияет на то, к каким функциям и переменным (символы ядра) он может получить доступ в ядре.

Загрузка в память модуля, для которого лицензия не соответствует GPL, приведет к
установке в ядре флага `tainted` (испорчено).

#### Пример использования

```
MODULE_LICENSE("GPL");
```

### Макрос `MODULE_AUTHOR`

Позволяет указать автора модуля. Значение этого макроса служит только для информационных целей.

#### Пример использования

```
MODULE_AUTHOR("Author");
```

### Макрос `MODULE_DESCRIPTION`

Позволяет указать описание модуля. Значение этого макроса служит только для информационных целей.

### Макрос `MODULE_SUPPORTED_DEVICE`

Помещает запись, описывающую, какое устройство поддерживается этим модулем. Комментарии в источниках ядра предполагают, что в конечном итоге эти параметры могут использоваться для автоматической загрузки модулей, но в настоящее время такое использование не производится.

### Макрос `MODULE_VERSION`

Позволяет указать версию модуля. Значение этого макроса служит только для информационных целей.

## Экспортируемые символы

- данные и функции, которыми могут пользоваться другие модули ядра. 

При загрузке модули динамически компонуются с ядром, в коде модулей могут вызываться только те функции ядра, которые явно экспортируются для использования.

### Макрос `EXPORTOL`

В ядре экспортирование осуществляется с помощью специального макроса `EXPORT_SYMBOL()`. Функции, которые экспортируются, доступны для использования модулям, остальные функции не могут быть вызваны из модулей. Для экспортируемых данных правило аналогично.

#### Пример использования

```
int md1_data = 42; // экспортируемые данные
extern int md1_func(int n) // экспортируемая функция
{
    return n * 2;
}
EXPORT_SYMBOL(md1_data);
EXPORT_SYMBOL(md1_func);
```

----

Чтобы другие модули могли использовать экспортированные символы, они должны “знать” их определение. Для этого применяются заголовочные файлы.

#### Пример заголовочного файла:

```
extern int md1_data;
extern int md1_func(int n);
```

### Макрос `EXPORT_SYMBOL_GPL`

Иногда необходимо, чтобы символы были доступны только для модулей, имеющих соответствующую лицензию GPL. Для этого используют макрос `EXPORT_SYMBOL_GPL()`.

## Команды linux для работы с загружаемыми модулями


### `insmod`

- загружает модуль в ядро из конкретного файла, если модуль зависит от других модулей,которые не загружены в ядро, то выдает ошибку и не загружает модуль.

### `lsmod`

- выводит список модулей, загруженных в ядро.

### `modinfo`

- извлекает информацию из модулей ядра (лицензия, автор, описание и т.д.).

### `rmmod`

- для выгрузки модуля из ядра, в качестве параметра передается имя файла модуля.

### `dmesg`

- команда для вывода буфера сообщений ядра в стандартный поток вывода.

Сообщения содержат информацию о драйверах устройств, загружаемых в ядро во время загрузки системы, а также при подключении аппаратного обеспечения к системе.

_Замечание: системный журнал используется большим числом процессов, и для того
чтобы было легче обнаружить сообщения конкретного модуля, рекомендуется в их
начало помещать некоторый идентификатор (к примеру знак + или имя модуля). В этом
случае просмотреть сообщения от модуля можно при помощи команды:__

```
dmesg | tail -n60 | grep +
```

## Работа с деревом модулей

Команда для загрузки модуля из дерева ядра со всеми зависимостями:

```
sudo modprobe
```

Команда работает только с деревом модулей, загрузка возможно только по имени
модуля, а не имени файла. Используется для подгрузки готовых модулей, включенных в
дерево модулей текущей версии ядра.

Для получения списка всех модулей из дерева каталогов, нужно выполнить команду:

```
find /lib/modules/`uname -r` -name '*.ko'
```

Вместо `uname -r` подставляется текущая версия ядра.

Для выгрузки модуля и всех модулей, которые зависят от него, используется команда:

```
sudo modprobe -r
```

Для создания списка зависимостей модулей используется команда:

```
sudo depmod -a
```

Данная команда считывает каждый модуль из каталога `/lib/modules/uname -r` и определяет, какие символы они экспортируют. 

Результат работы команды хранится в файле `modules.dep` в каталоге `/lib/modules/uname -r`.

## Задание 1

### Флаги

```
#define 	PF_EXITING   0x00000004 /* процесс завершает свою работу */
 
#define 	PF_EXITPIDONE   0x00000008 /* завершена работа процесса с идентификатором в процессе завершения */
 
#define 	PF_VCPU   0x00000010 /* я виртуальный процессор */
 
#define 	PF_WQ_WORKER   0x00000020 /* я работник очереди задач */
 
#define 	PF_FORKNOEXEC   0x00000040 /* процесс был форкнут, но не выполнил exec */
 
#define 	PF_MCE_PROCESS   0x00000080 /* процесс имеет политику для ошибок машинных проверок (MCE) */
 
#define 	PF_SUPERPRIV   0x00000100 /* использовались привилегии суперпользователя */
 
#define 	PF_DUMPCORE   0x00000200 /* процесс создал дамп памяти (core dump) */
 
#define 	PF_SIGNALED   0x00000400 /* процесс был завершён сигналом */
 
#define 	PF_MEMALLOC   0x00000800 /* процесс выделяет память */
 
#define 	PF_NPROC_EXCEEDED   0x00001000 /* превышен лимит по количеству процессов (RLIMIT_NPROC) */
 
#define 	PF_USED_MATH   0x00002000 /* процесс использует математическое сопроцессорное оборудование */
 
#define 	PF_NOFREEZE   0x00008000 /* этот поток не должен быть заморожен */
 
#define 	PF_FROZEN   0x00010000 /* поток заморожен для приостановки системы */
 
#define 	PF_FSTRANS   0x00020000 /* процесс находится внутри транзакции файловой системы */
 
#define 	PF_KSWAPD   0x00040000 /* я — процесс kswapd */
 
#define 	PF_LESS_THROTTLE   0x00100000 /* уменьшить замедление: я очищаю память */
 
#define 	PF_KTHREAD   0x00200000 /* я — ядровой поток */
 
#define 	PF_RANDOMIZE   0x00400000 /* рандомизация виртуального адресного пространства */
 
#define 	PF_SWAPWRITE   0x00800000 /* разрешено записывать в swap */
 
#define 	PF_SPREAD_PAGE   0x01000000 /* распределять страницы кэширования по cpuset */
 
#define 	PF_SPREAD_SLAB   0x02000000 /* распределять некоторые кэши slab по cpuset */
 
#define 	PF_THREAD_BOUND   0x04000000 /* поток привязан к определенному процессору */
 
#define 	PF_MCE_EARLY   0x08000000 /* ранняя остановка процесса при ошибках MCE */
 
#define 	PF_MEMPOLICY   0x10000000 /* нетрадиционная политика памяти для NUMA */
 
#define 	PF_MUTEX_TESTER   0x20000000 /* поток принадлежит тестеру для rt mutex */
 
#define 	PF_FREEZER_SKIP   0x40000000 /* не учитывать этот поток как замораживаемый */
```

### Коды состояний процессов

- D — не прерываемый сон (обычно ожидание ввода/вывода).
- I — неактивный (Idle) поток ядра.
- R — выполняется или готов к выполнению (находится в очереди выполнения).
- S — прерываемый сон (ожидание завершения события).
- T — остановлен сигналом управления заданиями.
- t — остановлен отладчиком во время трассировки.
- W — выгрузка из памяти (не используется начиная с ядра 2.6.xx).
- X — мертвый процесс (не должен встречаться).
- Z — зомби-процесс (defunct), завершён, но не удалён родительским процессом.

```
#define 	TASK_RUNNING   0        /* Задача выполняется или готова к выполнению */
 
#define 	TASK_INTERRUPTIBLE   1    /* Задача спит, можно разбудить сигналом */
 
#define 	TASK_UNINTERRUPTIBLE   2  /* Задача спит, сигналы не могут её разбудить */
 
#define 	__TASK_STOPPED   4        /* Задача остановлена сигналом SIGSTOP */
 
#define 	__TASK_TRACED   8         /* Задача отслеживается отладчиком */
 
#define 	EXIT_ZOMBIE   16          /* Задача завершена, но не очищена (зомби-процесс) */
 
#define 	EXIT_DEAD   32            /* Задача завершена и очищена */
 
#define 	TASK_DEAD   64            /* Процесс полностью уничтожен (не должен появляться) */
 
#define 	TASK_WAKEKILL   128       /* Задача должна быть убита при пробуждении */
 
#define 	TASK_WAKING   256         /* Задача пробуждается */
 
#define 	TASK_STATE_MAX   512      /* Максимальный предел для состояния задачи */
 
#define 	TASK_STATE_TO_CHAR_STR   "RSDTtZXxKW"  /* Множество возможных состояний в строке */
 
#define 	TASK_KILLABLE   (TASK_WAKEKILL | TASK_UNINTERRUPTIBLE)   /* 130 - Задача, которую можно убить (состояние TASK_WAKEKILL или TASK_UNINTERRUPTIBLE) */
 
#define 	TASK_STOPPED   (TASK_WAKEKILL | __TASK_STOPPED)   /* 132 - Остановленная задача, которая может быть убита */
 
#define 	TASK_TRACED   (TASK_WAKEKILL | __TASK_TRACED)   /* 136 - Отслеживаемая задача, которая может быть убита */
 
#define 	TASK_NORMAL   (TASK_INTERRUPTIBLE | TASK_UNINTERRUPTIBLE)   /* 3 - Нормальная задача, которая может быть либо прерываемой, либо непрерываемой */
 
#define 	TASK_ALL   (TASK_NORMAL | __TASK_STOPPED | __TASK_TRACED)   /* 15 Все возможные состояния задачи (нормальные, остановленные, отслеживаемые) */
```

```
state 2001:

TASK_WAKEKILL — задача должна быть убита при пробуждении.
__TASK_STOPPED — задача остановлена.
TASK_INTERRUPTIBLE — задача может быть пробуждена сигналом.
TASK_UNINTERRUPTIBLE — задача не может быть пробуждена сигналом.
TASK_DEAD — задача завершена.
TASK_TRACED — задача отслеживается отладчиком.
```

### `comm` - имя команды (только имя исполняемого файла)

- Процесс, помеченный как <defunct>, является частично завершённым и ожидает полного уничтожения родительским процессом.

### `task_cpu()` 

Этот макрос (или функция) определяет, на каком процессоре выполняется текущий процесс.

`current` — это указатель на текущий процесс (структуру task_struct).

`task_cpu()` возвращает ID процессора, на котором выполняется этот процесс.

### `prio` — текущий (динамический) приоритет процесса.

- Чем ниже значение, тем выше приоритет.
- Для RT-процессов (реального времени) диапазон: 0–99.
- Для обычных процессов: 100–139.

### `static_prio` — статический приоритет (изначально заданный процессу).

Не меняется автоматически (но можно изменить с помощью `nice` или `setpriority`).

### `normal_prio` — обычный приоритет, который используется планировщиком

- Для обычных процессов: `normal_prio` = `static_prio`.
- Для RT-процессов: `normal_prio` может быть выше.

### Политика планирования

- `SCHED_NORMAL (0)` — обычный процесс.

Используется для обычных процессов в системе. В Linux она реализована с использованием отложенного планировщика (на основе приоритетов).

Выделяется процессорное время на основе приоритета - процесс с более высоким приоритетом будет выполняться до тех пор, пока не истечет его квота или пока система не переключится на другой процесс.

- `SCHED_FIFO (1)` — реального времени (FIFO).

Для процессов реального времени. Она гарантирует, что процесс будет выполняться, пока не завершит свою задачу или не будет прерван.

Процесс с политикой `SCHED_FIFO` имеет непрерывное время работы, пока не завершится или не будет приостановлен процессом более высокого приоритета. FIFO-алгоритм не использует квоты времени, как в случае с обычным планировщиком.

Все процессы FIFO организуются в очередь, и процесс с более высоким приоритетом выполняется первым. Если два процесса имеют одинаковый приоритет, тот, который был добавлен первым, будет выполняться первым (FIFO). Если процесс прерывается, то он снова попадет в очередь и будет ожидать своего следующего исполнения.

- `SCHED_RR (2)` — реального времени (Round-Robin).

 Политика `Round-Robin (RR)` также используется для процессов реального времени. В отличие от `FIFO`, где процесс выполняется непрерывно, `Round-Robin` позволяет каждому процессу получать квоту времени для выполнения, после чего процесс переключается на следующий.

 В случае с `RR` процессы с одинаковым приоритетом выполняются по очереди в фиксированное время (квота). После того как процесс исчерпал свою квоту, планировщик передает управление следующему процессу с таким же приоритетом. После завершения всех процессов, очередь начинается заново.

 Приоритеты процессов не изменяются, но каждый процесс имеет фиксированное время (квоту), после которого он передается в конец очереди.

 Это также политика для процессов реального времени, но она используется, когда важно не только время отклика, но и равномерное распределение процессорного времени между всеми потоками с одинаковым приоритетом. Она подходит для многозадачности с несколькими высокоприоритетными процессами.

- `SCHED_BATCH (3)` — пакетный процесс.

Эта политика планирования предназначена для выполнения "пакетных" задач, которые могут длиться долго и не требуют быстрых откликов. 

Процессам, использующим политику SCHED_BATCH, выделяется процессорное время с приоритетом ниже обычных процессов. Это позволяет эффективно выполнять длительные или ресурсоемкие вычисления без блокировки более важных задач. Пакетные процессы выполняются, когда в системе нет активных высокоприоритетных задач.

 Такие процессы не могут блокировать другие процессы и, как правило, выполняются после того, как завершены все более важные задачи.

- `SCHED_IDLE (5)` — фоновый процесс.

 Политика SCHED_IDLE предназначена для процессов, которые выполняются в фоновом режиме и имеют самый низкий приоритет.

 Процесс с этой политикой будет выполняться только в том случае, если процессор не занят более важными задачами. Этот процесс получает процессорное время только тогда, когда нет других задач для выполнения, то есть когда система в целом простаивает.

 Эта политика используется для фоновых процессов, которые выполняют не критичные задачи, такие как сборка мусора, очистка кэш-памяти или другие неинтенсивные фоновые работы, которые могут подождать, если система занята другими важными процессами.

#### Как назначить политику планирования

В данном случае `RR`

```
sudo chrt -r -p 50 <PID>
```

```
ps -eo pid,comm,policy | grep RR

chrt -a -p $(pgrep -d' ' .)
```

### Время выполнения

- `utime` — время пользовательского режима (user time), в тиках (jiffies).

- `stime` — время системного режима (system time), тоже в тиках.

Их сумма — общее время выполнения процесса.

### Переключения контекста

`nvcsw + nivcsw` — общее количество переключений контекста:

- `nvcsw` — добровольные переключения (voluntary context switch).
- `nivcsw` — недобровольные переключения (involuntary context switch).

Чем выше `nivcsw`, тем чаще процесс принудительно вытеснялся планировщиком.

## Доп. инфа

Процесс `kthreadd` - управляет созданием и управлением рабочими потоками (например, kworker).

Приоритеты процессов в ядре могут быть определены различными факторами, такими как:

- Тип процесса (например, процесс ядра имеет более высокий приоритет по сравнению с обычным пользовательским процессом).
- Наличие и важность задач, которые выполняются этим процессом.

Процесс с идентификатором `0` — это процесс, который называется `swapper`, или `idle`. Это процесс, который выполняется на ядре, когда нет других задач для выполнения. Он находится в ожидании, пока не появятся задачи, которые требуют обработки. Процесс с ID 0 не существует в обычном пользовательском пространстве, он является частью ядра и управляет состоянием "сна" системы, если нет активных задач для выполнения.

###  Информация о процессе миграции (например, migration/0)

Процесс миграции, например, `migration/0`, является специальным процессом, который помогает системе управлять процессами, которые необходимо перенести с одного ядра на другое. В данном случае `migration/0` относится к процессу, который выполняет миграцию между ядрами процессора.

В Linux при наличии нескольких процессоров или ядер операционная система может решать, на каком ядре будет выполняться тот или иной процесс. Процесс миграции помогает системным потокам перемещаться между ядрами, чтобы сбалансировать загрузку.