# Виртуальная файловая система `/proc`

Папки и файлы виртуальной файловой системы `/proc` не хранятся на диске - создаются динамически при обращении к ним.

Файловая система `/proc` фактически представляет собой интерфейс ядра,
который позволяет получать информацию о процессах и ресурсах, которые
они используют. При этом используется стандартный интерфейс файловой
системы и системных вызовов. Из этого следует, что **управление доступом к адресному пространству осуществляется при помощи обычных прав доступа – на чтение, на запись и выполнение**.

Общее взаимодействие с proc заключается в использовании `cat` и `echo` из оболочки – командной строки.

Данные о каждом процессе хранятся в поддиректории с именем, которым является идентификатор процесса: `/proc/<PID>`. В поддиректории процесса находятся файлы и поддиректории, содержащие данные о процессе.

# Загружаемые модули ядра и виртуальная файловая система `/proc`

Файлы и поддиректории файловой системы `/proc` могут создаваться, их можно регистрировать и прекращать их регистрацию. Поэтому `/proc` часто используются загружаемыми модулями ядра. 

Файлы и поддиректории файловой системы `/proc` используют структуру `proc_dir_entry`.

```
#include <linux/proc_fs.h>

int proc_register(struct proc_dir_entry *parent, struct proc_dir_entry *child);
int proc_register_dynamic(struct proc_dir_entry *parent, struct proc_dir_entry *child);
int proc_unregister(struct proc_dir_entry *parent, int inode);
```

Функции `proc_register` и `proc_register_dynamic` добавляют узлы (файлы или директории) в виртуальную файловую систему `/proc`:

* `proc_register` — регистрирует узел с заданным **inode**.
* `proc_register_dynamic` — автоматически назначает свободный **inode**.
* `proc_unregister` — удаляет узел по номеру **inode**.

**inode** — индексный дескриптор файла, это внутренняя структура ядра Linux, которая описывает сам файл как объект: его тип, владельца, права, размер, временные метки и указатели на данные на диске.

!!! **inode представляет все файлы, даже если они ещё не открыты. Он отражает сам "факт существования" файла в файловой системе.**

Каждый узел описывается структурой `proc_dir_entry`, содержащей информацию о названии, правах доступа, владельце, размере, обработчиках иерархии и пользовательских данных.

```
struct proc_dir_entry {
    unsigned short low_ino;       // Номер inode для директории (уникален в /proc)
    // Для proc_register этот номер должен быть уникальным в файловой системе /proc, 
    // значения определены в <linux/proc_fs.h>. Для proc_register_dynamic номер inode 
    // назначается динамически.

    unsigned short namelen;       // Длина имени узла (без '\0')
    const char *name;             // Уникальное имя виртуального файла (имя данного узла)
    mode_t mode;                  // Тип и права доступа к узлу (из <linux/stat.h>)
    nlink_t nlink;                // Количество ссылок (2 для директорий, 1 для файлов)
    uid_t uid;                    // UID владельца (обычно 0)
    gid_t gid;                    // GID владельца (обычно 0)
    unsigned long size;          // Размер, отображаемый при stat (можно 0)
    struct inode_operations *ops;// Операции inode (NULL или &proc_dir_inode_operations)
    int (*get_info)(             // Обработчик чтения (для файлов, не директорий)
        char *buffer,
        char **start,
        off_t offset,
        int length,
        int unused
    );
    void (*fill_inode)(          // Доп. настройка inode при работе с директорией (обычно NULL)
        struct inode *
    );
    struct proc_dir_entry *next;   // Следующий элемент в списке (заполняется ядром)
    struct proc_dir_entry *parent; // Родительский элемент (заполняется ядром)
    struct proc_dir_entry *subdir; // Первый дочерний элемент (заполняется ядром)
    void *data;                  // Пользовательские данные (можно использовать в своих хендлерах)
};
```

Cтруктура `struct proc_ops` используется для задания обработчиков операций с файлами в `/proc`.

```
struct proc_ops {
    unsigned int proc_flags;
    // Флаги, определяющие поведение узла (например, PROC_ENTRY_PERMANENT).
    // Используется ядром для внутренней логики /proc.

    int (*proc_open)(struct inode *inode, struct file *file);
    // Вызывается при открытии файла (например, через cat /proc/myfile).
    // Здесь можно инициализировать данные, выделить память и т.д.

    ssize_t (*proc_read)(struct file *file, char __user *buf,
                         size_t count, loff_t *ppos);
    // Обработчик чтения. Вызывается при read().
    // Нужно записать данные в буфер пользователя (buf), не больше count байт.
    // *ppos — смещение, используется для многоразового чтения.

    ssize_t (*proc_read_iter)(struct kiocb *iocb, struct iov_iter *iter);
    // Альтернатива proc_read для поддержки vectored I/O (реже используется).
    // Предоставляет интерфейс для чтения сразу в несколько буферов.

    ssize_t (*proc_write)(struct file *file, const char __user *buf,
                          size_t count, loff_t *ppos);
    // Обработчик записи. Вызывается при write().
    // Нужно считать данные из пользовательского буфера buf.

    loff_t (*proc_lseek)(struct file *file, loff_t offset, int whence);
    // Перемещение "курсорной позиции" в файле (аналог lseek).
    // Обычно реализуется с помощью default_llseek().

    int (*proc_release)(struct inode *inode, struct file *file);
    // Вызывается при закрытии файла (после чтения/записи).
    // Можно освободить ресурсы, выделенные в proc_open.

    __poll_t (*proc_poll)(struct file *file, struct poll_table_struct *wait);
    // Поддержка poll(), select(), epoll.
    // Уведомляет, когда узел готов для чтения/записи без блокировки.

    long (*proc_ioctl)(struct file *file, unsigned int cmd, unsigned long arg);
    // Обработка ioctl-запросов (управляющих команд).
    // Используется редко, но позволяет выполнять спец. команды на уровне ядра.

#ifdef CONFIG_COMPAT
    long (*proc_compat_ioctl)(struct file *file, unsigned int cmd, unsigned long arg);
    // Обработка ioctl от 32-битных приложений в 64-б
```

# Файловая система `/proc`: создание файлов, доступных для чтения

Методика работы с файловой системой `/proc`: создаётся структура со всей необходимой
информацией, включая указат`ели на функции-обработчики; функция `init_module()` регистрирует структуру, а `module_exit()` отменяет регистрацию.

Основная причина, по которой используется `proc_register_dynamic` состоит в том, что номер `inode`, для создаваемого файла, заранее неизвестен, поэтому ядро может определить его самостоятельно, чтобы предотвратить возможные конфликты.

Можно также создавать каталоги в файловой системе /proc, используя
`proc_mkdir()`, а также символические ссылки с `proc_symlink()`. Для простых
`/proc`-записей, для которых требуется только функция чтения, используется
`create_proc_read_entry()`, которая создает запись `/proc` и инициализирует
функцию `read_proc` в одном вызове. 

Прототипы этих функций:

```
extern struct proc_dir_entry *proc_symlink(const char *,
struct proc_dir_entry *, const char *);
extern struct proc_dir_entry *proc_mkdir(const char *, struct proc_dir_entry *);
struct proc_dir_entry *create_proc_read_entry( const char *name, mode_t mode,
struct proc_dir_entry *base, read_proc_t *read_proc, void *data );
```

# Передача данных из режима пользователя в режим ядра и из режима ядра в режим пользователя

Ядро загружено в физическую память (при запуске на выполнение ОС). Процессы имеют защищенные виртуальные адресные пространства. Отображение виртуальной памяти на физическую осуществляется через таблицы страниц процессов (рис. 1). Аппаратная часть непосредственно выполняет отображение виртуальных страниц на физические, а ядро управляет таблицами и их конфигурацией. 

В физической памяти будут находиться только те страницы, с которыми процессор обращается
в текущий момент. При этом страницы загружаются в память «по запросу», когда процессор
обращается к странице, которая отсутствует в памяти.

Не все страницы памяти могут быть выгружены (например, это может быть код ядра,
отвечающий за прерывания, или код управления страничными таблицами и логикой
подкачки). Такие страницы никогда не должны выгружаться и поэтому являются закрепленными (`pinned`), т. е. постоянно находятся в оперативной памяти. Страницы адресного пространства пользователя могут быть выгружены, однако их можно закрепить с помощью функции `mlock` (или `mlockall`). 

Для взаимодействия приложений с ядром и ядра с приложениями используются
следующие функции:

## Функция (User Space Memory Access)

Копирует данные из ядра в пространство пользователя. Вызывающий
абонент должен проверить указанный блок с помощью `access_ok` до
вызова этой функции.

```
unsigned long __copy_to_user (void __user * to, const void *from, unsigned long n);
```

Формальные параметры:
* `void __user * to` - Адрес назначения находится в пространстве пользователя.
* `const void * from` - Адрес источника находится в пространстве ядра.
* `unsigned long n` - количество копируемых байт.


Возвращает количество байт, которые не могут быть скопированы. 
В случае успешного выполнения будет возвращен 0.

## Функция (User Space Memory Access)

```
unsigned long __copy_from_user (void * to, const void __user *from, unsigned long n);
```

Копирует данные из пространства пользователя в пространство ядра.
Вызывающий абонент должен проверить указанный заданный блок с помощью
`access_ok` до вызова этой функции.

Формальные параметры:
`void * to` - Адрес назначения находится в пространстве ядра.
`const void __user *from` - адрес источника находится в пространстве пользователя.
`unsigned long n` - количество копируемых байт.


Возвращает количество байт, которые не могут быть скопированы. 
В случае успешного выполнения будет возвращен 0.
Если некоторые данные не могут быть скопированы, эта функция добавит нулевые байты к
скопированным данным до требуемого размера.

### Альтернативная версия 

```
__copy_from_user_inatomic 
```
- может быть вызвана из атомарного контекста и не сможет «спать». 
В этом случае не скопированные байты *НЕ* будут заполнены нулями. 

