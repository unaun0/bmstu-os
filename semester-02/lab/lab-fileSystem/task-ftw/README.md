# Файловая система

## Четыре функции семейства stat

```#include <sys/stat.h>```

Эти функции возвращают информацию о файле в буфере, на который указывает `statbuf`.
Для самого файла не требуется никаких разрешений, но — в случае `stat()`, `fstatat()` и `lstat()`
— разрешение на выполнение (поиск) требуется для всех каталогов в `pathname`, которые
ведут к файлу.

```
int stat(const char *restrict pathname, struct stat *restrict buf);
```

- возвращает структуру с информацией о файле, указанном в
аргументе `pathname`; выводит содержимое полей дескриптора файла.


```
int lstat(const char *restrict pathname, struct stat restrict buf);
```

- работает идентично `stat`, но в случае символьных сcылок возвращает информацию о самой ссылке, а не о файле.

```
int fstat(int fd, struct stat *buf);
```

- работает идентично `stat`, только возвращается информация об открытом файле, на который указывает файловый дескриптор `fd` (возвращаемый open()).

```
int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);
```

- работает идентично `stat`, возвращает информацию о файле, путь `pathname`
к которому начинается в открытом каталоге, представленном файловым дескриптором `fd`.

Аргумент `flag` определяет правила следования по символическим ссылкам: `AT_SYMLINK_NOFOLLOW` - функция `fstatat` не будет следовать по символическим ссылкам, а вернет информацию о самой ссылке.

Если в аргументе `fd` передать значение `AT_FDCWD`, а в аргументе `pathname` — короткое имя файла, путь к файлу `pathname` будет откладываться относительно текущего каталога.

Если в аргументе `pathname` передать строку абсолютного пути, аргумент `fd` будет
игнорироваться. В этих двух случаях `fstatat` действует подобно `stat` или `lstat`, в
зависимости от значения аргумента `flag`.

Второй аргумент `buf` является указателем на структуру, которую функция заполнит
информацией.

Все эти функции возвращают структуру `stat`.

## Структура stat

```
struct stat {
    dev_t         st_dev;      /* устройство */
    ino_t         st_ino;      /* inode */
    mode_t        st_mode;     /* режим доступа */
    nlink_t       st_nlink;    /* количество жестких ссылок */
    uid_t         st_uid;      /* идентификатор пользователя-владельца */
    gid_t         st_gid;      /* идентификатор группы-владельца */
    dev_t         st_rdev;     /* тип устройства */
                               /* (если это устройство) */
    off_t         st_size;     /* общий размер в байтах */
    blksize_t     st_blksize;  /* размер блока ввода-вывода */
                               /* в файловой системе */
    blkcnt_t      st_blocks;   /* количество выделенных блоков */
    time_t        st_atime;    /* время последнего доступа */
    time_t        st_mtime;    /* время последней модификации */
    time_t        st_ctime;    /* время последнего изменения */
};
```

## Чтение каталогов

Прочитать информацию из файла каталога может любой, кто имеет право на чтение этого каталога. Но только ядро может выполнять запись в каталоги, благодаря чему обеспечивается сохранность файловой системы. 

Известно, что возможность создания и удаления файлов в каталоге определяется битами прав на запись и на выполнение, но это не относится к непосредственной записи в файл каталога. 

Фактический формат файлов каталогов зависит от реализации UNIX и архитектуры файловой системы.

## Функции для работы с каталогами

```
DIR *opendir(const char *pathname);
```

- открывает поток каталога, соответствующий каталогу name, и возвращает указатель на этот поток. Поток устанавливается на первой записи в каталоге; возвращает указатель на поток каталога или `NULL` в случае ошибок.  

```
DIR *fdopendir(int fd);
```

- похожа на `opendir()`, но возвращает поток каталога для каталога, на который ссылается открытый файловый дескриптор `fd`. После успешного вызова `fdopendir()`, дескриптор `fd` используется только внутри реализации и не должен использоваться в приложении.

**!!!** Функция `opendir()` устанавливает флаг `close-on-exec` для файлового дескриптора, указывающего на `DIR *`. Функция `fdopendir()` оставляет флаг `close-on-exec` не изменённым для файлового дескриптора `fd`.

**Флаг `close-on-exec`:** является атрибутом самого дескриптора файла; когда установлен, система автоматически закрывает файл, когда процесс осуществляет exec; установив этот флаг сразу после открытия файла, вам не нужно беспокоиться о том, что какой-нибудь порожденный процесс случайно его унаследует.

```
struct dirent *readdir(DIR *dp);
```

- возвращает указатель на структуру `dirent`, представляющую следующую запись каталога в потоке каталога, указанного в `dp`. Функция возвращает `NULL` по достижении последней записи в потоке каталога или если произошла ошибка.

```
struct dirent {
    ino_t          d_ino;       /* номер иноды */
    off_t          d_off;       /* не смещение, смотрите ниже */
    unsigned short d_reclen;    /* длина этой записи */
    unsigned char  d_type;      /* тип файла; поддерживается
                                   не во всех файловых системах */
    char           d_name[256]; /* имя файла с null в конце */
};
```

```
void rewinddir(DIR *dp); int closedir(DIR *dp);
```

- сбрасывает текущее положение потока каталога `dp` в начало каталога.

```
long telldir(DIR *dp);
```

- возвращает текущее положение, связанное с потоком каталога `dp`.

```
void seekdir(DIR *dp, long loc);
```

- устанавливает в потоке каталога позицию, с которой начнёт работу следующий вызов `readdir()`; аргумент `loc` должен быть значением, которое возвращается ранее вызванной функцией `telldir()`.

## Перемещение по дереву каталогов

`ftw`, `nftw` - команды перемещения по дереву каталогов.

```
#include <ftw.h>
```

```
int ftw(const char *dir, int (*fn)(const char *file, const struct stat *sb, int flag), int nopenfd);
```

```
int nftw(const char *dir, int (*fn)(const char *file, const struct stat *sb, int flag, struct FTW *s), int nopenfd, int flags);  
```

- перемещается по дереву каталогов, начиная с указанного каталога `dir`. Для каждого найденного элемента дерева вызываются: `fn()` с указанием полного имени этого элемента, указатель на структуру элемента `stat()` и целое число. 

Значения этого целого числа `flag`могут быть одним из следующих:
* FTW_F (обычный файл);
* FTW_D (каталог);
* FTW_DNR (каталог, который не может быть считан);
* FTW_SL (символьная ссылка);
* FTW_NS (ошибка в элементе, который не является символьной ссылкой).

Если элемент - символьная ссылка и в нем происходит ошибка, то XPG4v2 утверждает, что данный элемент не определен (вне зависимости от того, используется ли `FTW_NS` и `FTW_SL` или нет).

`ftw()` рекурсивно вызывает саму себя для перемещения по обнаруженным каталогам, обрабатывая каждый каталог перед обработкой вложенных в него файлов и подкаталогов.

Для того, чтобы избежать использования всех описателей файлов, `nopenfd` определяет максимальное количество одновременно открытых каталогов. Когда это количество будет превышено, работа `ftw()` немного замедляется, так как каталоги будут закрываться и снова открываться. `ftw()` использует в целом один описатель файлов для работы с каждым уровнем файловой иерархии.

Для остановки исследования дерева каталогов `fn()` возвращает ненулевое значение; оно станет возвращаемым значением для `ftw()`. Иначе `ftw()` будет продолжать свой поиск, пока не исследует все дерево полностью (в этом случае она возвратит ноль) или пока не появится ошибка, отличная от ошибок `EACCES`. В этом случае функция возвратит значение -1.

Так как `ftw()` использует динамическую структуру данных, то единственным безопасным способом для выхода из процесса перемещения по дереву будет возврат ненулевого значения. Для обработки прерываний, например, необходимо отметить, что прерывание действительно произошло, и вернуть ненулевое значение.

Функция `nftw()` выполняет то же самое, что и `ftw()`, только имеет еще один параметр, `flags`, Этот параметр `flags` есть 0 или логическое ИЛИ нескольких следующих параметров:

* `FTW_CHDIR` - eсли установлен этот флаг, то будет выполняться `chdir()` для каждого каталога перед обработкой его содержимого.
* `FTW_DEPTH` - eсли установлен этот флаг, то производить глубокий поиск, т.е. функция для обработки самого каталога вызывается только после того, как обработано содержимое его самого и его подкаталогов.
* `FTW_MOUNT` - eсли установлен этот флаг, то работать только в одной файловой системе.
* `FTW_PHYS` - Если установлен этот флаг, то не следовать по символьным ссылкам. Если флаг не включен, то идет следование по символьным ссылкам, но ни один файл дважды обработан не будет.

* Если `FTW_PHYS` выключен, а `FTW_DEPTH` включен, то функция `fn()` никогда не будет вызвана для каталога, который является своим потомком.

Функция `fn()` вызывается с четырьмя параметрами: 
1. полным путем к элементу, 
2. указателем на структуру `struct stat` этого элемента, 
3. целым, описывающим его тип,
4. указателем на структуру `struct FTW`. 

Тип будет одним из следующих: `FTW_F, FTW_D, FTW_DNR, FTW_SL, FTW_NS` (если значение его равно описанному выше, то `FTW_SL` будет работать только с указанным флагом `FTW_PHYS`) или `FTW_DP`
(элемент является каталогом, и все его потомки уже были обработаны). 
Это случается, только если флаг `FTW_DEPTH` запущен.

```
fullpath = path_alloc(&len); /* выделить память для PATH_MAX+1 байт */
/* (Стивенс, Стивен: листинг 2.3 стр. 85) */
```

```
#include <unistd.h>
int chdir(const char *path);
int fchdir(int fd);  
```

- `chdir` изменяет текущий каталог каталог на `path`.
- `fchdir` идентично `chdir`, только каталог задан в виде открытого файлового дескриптора.

# Stack

![](https://habrastorage.org/webt/so/mq/xc/somqxc24t6u7_f2ol0baenjtoqi.jpeg)

# Точки выхода из "рекурсии" 

1. Ошибки при вызове сиситемноых вызовов;
2. Нет прав для выполнения чтения (поиска) каталога;
3. Если не директория;
4. Стек пуст.