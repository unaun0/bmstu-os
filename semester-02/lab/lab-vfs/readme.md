# Создание виртуальной файловой системы

* VFS определяет интерфейс, который должны поддерживать конкретные файловые системы, чтобы работать в Linux.

* Linux поддерживает большое количество файловых систем - для того, чтобы это было возможно в VFS определена структура, определяющая тип файловой системы - `struct file_system_type`

* Для каждого типа файловой системы существует только одна структура `file_system_file`, независимо от того, сколько таких файловых систем смонтировано и смонтирован ли хотя бы один экземпляр файловой системы.

## Регистрация и монтирование файловой системы

Для связывания файловой системы с VFS необходимо определить некий минимальный набор функций и структур данных:

* `struct file_system_type` является глобальным "определителем" файловой системы и содержит имя ФС, а также функции инициализации и уничтожения суперблока.
* `struct super_operations` содержит набор функций работы с глобальными данными файловой системы. Здесь могут использоваться "заглушки", предоставляемые `libfs`.
* `struct file_operations` определяет набор функций для работы с файлами. Для файлов cчетчиков мы реализуем только три из них: `open`, `read` и `write`; для каталогов же используем "заглушки" `libfs`.

Код файловой системы может быть реализован или в виде загружаемого модуля ядра, или статически связан с ядром.

Для создания новой файловой системы надо заполнить поля структуры `struct file_system_file` и зарегистрировать файловую систему VFS с помощью следующих функции API:

```
#include <linux/fs.h>
extern int register_filesystem (struct file_system_type *); 
extern int unregister_filesystem (struct file_system_type *);
```

Регистрация файловой системы выполняется в функции инициализации модуля. Для дерегистрации файловой системы используется функция `unregister_filesystem()`, которая вызывается в функции выхода загружаемого модуля.

Обе функции принимают как параметр указатель на структуру `file_system_type`, которая "описывает" создаваемую файловую систему.

Например:
```
struct file_system_file my_fs_type = {
    .owner = THIS_MODULE,
    .name = “my_fs”,
    .mount = my_mount,
    .kill_sb = my_kill_super_block,
    .fs_flags = FS_REQUIRED_DEV,
};
```

* Поле `owner` отвечает за счетчик ссылок на модуль, чтобы его нельзя было случайно выгрузить. 

Например, если файловая система была подмонтирована, то выгрузка модуля может привести к краху, но счетчик ссылок не позволит выгрузить модуль пока он используется, т.е. пока файловая система не будет размонтирована.

* Поле `name` хранит название файловой системы. Именно это название будет использоваться при ее монтировании.

* `mount` и `kill_sb` два поля, хранящие указатели на функции - первая функция будет вызвана при монтировании файловой системы, а вторая при размонтировании. Достаточно реализовать всего одну, а вместо второй будем использовать `kill_block_super`, которую предоставляет ядро, или соответствующую generic-функцию.

Когда делается запрос на монтирование файловой системы в каталог в определенном
пространстве имен, VFS вызывает соответствующий метод `mount()` для конкретной файловой
системы.

В первую очередь заполняется структура `super_block`: магическое число, по которому драйвер файловой системы может проверить, что на диске хранится именно та самая файловая система, а не что-то еще или прочие данные; операции для суперблока, его размер. Для магического числа можно использовать любое сочетание цифр.

Проинициализировав суперблок, функция `myfs_fill_sb()` создает корневой каталог файловой системы. Для него создается `inode` вызовом `myfs_make_inode`. Он нуждается в указателе на суперблок и аргументе `mode`, который задает разрешения на создаваемый файл и его тип (маска S_IFDIR говорит функции, что мы создаем каталог). Файловые и inode-операции, которые мы назначаем новому `inode`, взяты из `libfs`, т.е. предоставляются ядром.

Далее для корневого каталога создается структура `dentry`, через которую он помещается в `directory-кэш. Заметим, что суперблок имеет специальное поле, хранящее указатель на `dentry корневого каталога, которое также устанавливается myfs_fill_sb.

В `put_super()` определяется деструктор суперблока разрабатываемой файловой системы. Остальные поля заполняются заглушками из `libfs`.

Сборка и загрузка драйвера системы ничем не отличается от сборки и загрузки обычного модуля, т.е. используются уже знакомые команды `insmod` и `rmmod`.
Вместо реального диска для экспериментов будем использовать `loop` устройство. Это такой драйвер "диска", который пишет данные не на физическое устройство, а в файл (образ диска). 

## Динамическое управление памятью - кэш slab

Распределитель памяти slab, используемый в Linux, строится вокруг объекта кэширования. Внутри ядра значительное количество памяти выделяется на ограниченный набор объектов, например, дескрипторы файлов и другие общие структурные элементы. Количество времени, необходимое для инициализации регулярного объекта в ядре, превышает количество времени, необходимое для его выделения и освобождения. Идея состояла в том, что вместо того, чтобы возвращать освободившуюся память в общий фонд, оставлять эту память в проинициализированном состоянии для использования в тех же целях. 

Например, если память выделена для mutex, функцию инициализации mutex (mutex_init) необходимо выполнить только один раз, когда память впервые выделяется для mutex. Последующие распределения памяти не требуют выполнения инициализации, поскольку она уже имеет нужный статус от предыдущего освобождения и обращения к деконструктору.

### Функции API

Первый этап - создание структуры кэша slab, которую можно создать статически как:
```
struct struct kmem_cache *my_cachep;
struct kmem_cache *kmem_cache_create( const char *name, size_t size, size_t align, unsigned long flags, void (*ctor)(void*, struct kmem_cache *, unsigned long), void (*dtor)(void*, struct kmem_cache *, unsigned long));
```

Эта ссылка затем используется другими функциями кэша slab для создания, удаления, распределения и т.д. 

Структура `kmem_cache` содержит данные, относящиеся к конкретным CPU-модулям, набор настроек (доступных через файловую систему proc), статистических данных и элементов, необходимых для управления кэшем slab.

Функция ядра `kmem_cache_create()` используется для создания нового кэша. Обычно это происходит во время инициализации ядра или при первой загрузке модуля ядра. Его прототип определен как: 

* `name` — строка имени кэша;
* `size` — размер элементов кэша (единый и общий для всех элементов);
* `offset` — смещение первого элемента от начала кэша (для обеспечения соответствующего выравнивания по границам страниц, достаточно указать 0, что означает выравнивание по умолчанию);
* `flags` — опциональные параметры (может быть 0);
* `ctor`, `dtor` — конструктор и деструктор, соответственно, вызываются при размещении-освобождении каждого элемента, но с некоторыми ограничениями; например, деструктор будет вызываться (финализация), но не гарантируется, что это будет поисходить сразу непосредственно после удаления объекта.

Из флагов создания, поскольку они также находятся в постоянном изменении, и большая часть из них относится к отладочным опциям, стоит назвать:
* `SLAB_HWCACHE_ALIGN` — расположение каждого элемента в слабе должно выравниваться по строкам процессорного кэша, это может существенно поднять производительность, но непродуктивно расходуется память;

* `SLAB_POISON` — начально заполняет слаб предопределённым значением (A5A5A5A5) для обнаружения выборки неинициализированных значений;

Если не нужны какие-то особые изыски, то нулевое значение будет вполне уместно для параметра flags.

После того как кэш создан, ссылка на него возвращается функцией `kmem_cache_create`. Обратите внимание, что эта функция не выделяет память кешу. Вместо этого при попытке выделить объекты из кэша (изначально он пуст) ему выделяется память при помощи команды `refill`. Это та же команда, которая используется для добавления кэшу памяти, когда все его объекты израсходованы.
Как для любой операции выделения, ей сопутствует обратная операция по уничтожению слаба: 

```
int kmem_cache_destroy( kmem_cache_t *cache );
```

Операция уничтожения может быть успешна (здесь достаточно редкий случай, когда функция уничтожения возвращает значение результата), только если уже все объекты, полученные из кэша, были возвращены в него. Таким образом, модуль должен проверить статус, возвращённый `kmem_cache_destroy()`; ошибка указывает на какой-то вид утечки памяти в модуле (так как некоторые объекты не были возвращены).

После того, как кэш объектов создан, вы можете выделять объекты из него, вызывая функцию `kmem_cache_alloc()`. Вызывающий код передает кэш, из которого выделяется объект, и набор флагов:

```
void kmem_cache_free( kmem_cache_t *cache, const void *obj );
```

## Вопросы

* Как зарегистрировать файловую систему?

*Проинициализировать поля структуры `file_system_type` и передать ее в `register_filesystem`*

* Как смонтировать файловую систему?

1. Зарегистрировать mount в `file_system_type`
2. Дальше по коду: вызывается `mount_[b|no]dev` в нее передается `fill_super` (функция выполняющая основную работу). В ней инициализируются поля структуры суперблок и создается `inode` Инициализируется поля структуры `inode` и устанавливается поле `s_root` суперблока. Этот `inode` нужен для установки корневого каталога суперблока.

* Смонтировать ФС в две папки и показать.

```
/proc/mount (что она смонтирована 2 раза)
/proc/filesystems (что она зарегана)
lsmod (что она загружена и там 2 ссылки)
/proc/slabinfo показать слаб кэш
```

* Нужно увеличить слаб кэш

```
myvfs_cache           128    128     32    1 : tunables    0    0    0 : slabdata     1    1      0
```

будет что-то такое в `slabinfo`. Нужно поменять в цикле количество создаваемых структур на 130

```
for (int i = 0; i < 130; i++) {
    cache_mem[i] = kmem_cache_alloc(cache, GFP_KERNEL);
    ...
}
```

И показать что тут 2 теперь
```
myvfs_cache           256    256     32    1 : tunables    0    0    0 : slabdata     2    2      0
```

* Зачем слабы?

*Для повторного использования проинициализированных объектов. Побочный эффект - устранение фрагментации (за счет повторного использования проинициализированных объектов)*

1. где у нас в коде используется slab (кеш)
- там тыкни ей в md_init на функцию <что-то там>_alloc
1. когда у нас создаётся новый slab?
- когда у нас заканчивается старый
Там ещё надо запустить прогу с 130 объектами (cache_count в Лерином коде поменял с 1 на 130) и показать в /proc/slabinfo что наш слеб цифорка 2 есть
1. точки входа
- init, exit, mount, kill_superblock
1. когда вызывается mount
- при выполнении команды mount в консоле
1. когда вызывается kill_superblock
- при выполнении команды unmount (она агриться если назвать её umount) в консоли

Вопросы, которые магистр задавал по vfs и возможные ответы на них

Зачем vfs?
Интерфейс, который унифицирует доступ к файлам

Зачем индексный дескриптор?
Для определения блоков памяти на диске, которые составляют файл

Какие абстракции?
Супер блок, файл,  inod, struct dentry

Какие операции над этими абстракциями?
Создание, удаление, time (?), кому разрешено читать/писать (?)

Что она просит показать?

Stepa, [13.06.2024 12:30]
Маунт в разные директории

Stepa, [13.06.2024 12:30]
Показать, что система зарегистрирована

Stepa, [13.06.2024 12:30]
И по коду

Екатерина Самарина, [13.06.2024 14:30]
VFS:
Я подошла сразу с дважды подмонтированной моей файловой системой.

1. Покажите, что она зарегистрирована
cat /proc/filesystems
Там в самом низу должна быть ваша ФС
2. Что нужно сделать, чтобы зарегистрировать ФС? Прям по коду
Проинициализировать поля структуры file_system_type, предварительно написав функции mount и kill_block_super. Далее экземпляр структуры передать в register_filesystem (двойник - функция unregister_filesystem)

Далее пошли по коду mount. Там вызываем функцию mount_nodev, куда передаем опять же заранее написанную функцию fill_sb. Далее комментируем код fill_sb. Там инициализируем поля структуры struct superblock. Далее она что-то начала спрашивать про inode, но в итоге ответила за меня, и я если честно, почти ничего не поняла😅
Далее она спросила, где определяем название корневого каталога (или что-то типа того). Это мы делаем командой в терминале mkdir, потом название созданной папке передаем команде mount

зачем нужна структура суперблок? вфс
спасите человека 

хахахахах

Описывает Смонтированную файловую систему