# Создание виртуальной файловой системы

* VFS определяет интерфейс, который должны поддерживать файловые системы, чтобы работать в Linux - для этого существует **структура, определяющая тип файловой системы** - `struct file_system_type`

* Для каждого типа файловой системы - одна структура `file_system_file`, независимо от того, сколько таких файловых систем смонтировано.

## Регистрация и монтирование файловой системы

Для связывания файловой системы с VFS необходимо определить минимальный набор функций и структур данных:

* `struct file_system_type` является **глобальным "определителем" файловой системы и содержит имя ФС, а также функции инициализации и уничтожения суперблока**.

* `struct super_operations` содержит набор функций работы с глобальными данными файловой системы.

* `struct file_operations` определяет набор функций для работы с файлами. Для файлов cчетчиков мы реализуем только три из них: `open`, `read` и `write`; для каталогов же используем "заглушки" `libfs`.

Код файловой системы может быть реализован или в виде загружаемого модуля ядра, или статически связан с ядром.

**Для создания новой файловой системы надо заполнить поля структуры `struct file_system_type` и зарегистрировать файловую систему VFS с помощью следующих функции API:**

```
#include <linux/fs.h>
extern int register_filesystem (struct file_system_type *); 
extern int unregister_filesystem (struct file_system_type *);
```

Регистрация файловой системы выполняется в функции инициализации модуля. Для дерегистрации файловой системы вызывается в функции выхода загружаемого модуля.

Обе функции принимают как параметр указатель на структуру `file_system_type`, **которая "описывает" создаваемую файловую систему**.

```
struct file_system_type my_fs_type = {
    .owner = THIS_MODULE, // отвечает за счетчик ссылок на модуль
    .name = “my_fs”, // название файловой системы
    .mount = my_mount,
    .kill_sb = my_kill_super_block,
    .fs_flags = FS_REQUIRED_DEV,
};
```

* Например, если файловая система была подмонтирована, то выгрузка модуля может привести к краху, но счетчик ссылок не позволит выгрузить модуль пока он используется, т.е. пока файловая система не будет размонтирована.

* Название будет использоваться при ее монтировании.

* `mount` и `kill_sb` два поля, хранящие указатели на функции - первая функция будет вызвана при монтировании файловой системы, а вторая при размонтировании. Достаточно реализовать всего одну, а вместо второй будем использовать `kill_block_super`, которую предоставляет ядро.

Когда делается запрос на монтирование файловой системы в каталог в определенном
пространстве имен, VFS вызывает соответствующий метод `mount()` для конкретной файловой
системы.

`mount_nodev()` — стандартная функция ядра для файловых систем, не привязанных к устройству.

Она:
1. Создает новый суперблок (superblock) для ФС.
2. Вызывает переданную функцию myfs_fill_sb для его инициализации.
3. Возвращает корневой dentry (виртуальную корневую директорию).

В первую очередь заполняется структура `super_block`: магическое число (по которому драйвер файловой системы может проверить, что на диске хранится именно та самая файловая система, а не что-то еще или прочие данные), операции для суперблока, его размер.

Проинициализировав суперблок, функция `myfs_fill_sb()` создает корневой каталог файловой системы. Для него создается `inode` вызовом `myfs_make_inode`. Он нуждается в указателе на суперблок и аргументе `mode`, который задает разрешения на создаваемый файл и его тип (маска S_IFDIR говорит функции, что мы создаем каталог).

Далее для корневого каталога создается структура `dentry`, через которую он помещается в directory-кэш. Заметим, что суперблок имеет специальное поле, хранящее указатель на `dentry` корневого каталога, которое также устанавливается `myfs_fill_sb`.

В `put_super()` определяется деструктор суперблока разрабатываемой файловой системы.

Сборка и загрузка драйвера системы ничем не отличается от сборки и загрузки обычного модуля, т.е. используются уже знакомые команды `insmod` и `rmmod`.

## Динамическое управление памятью - кэш slab

Распределитель памяти `slab` строится вокруг объекта кэширования. Внутри ядра значительное количество памяти выделяется на ограниченный набор объектов. Количество времени, необходимое для инициализации объекта в ядре, превышает количество времени, необходимое для его выделения и освобождения. 

**Вместо того, чтобы возвращать освободившуюся память в общий фонд, оставлять эту память в проинициализированном состоянии для использования в тех же целях**. 

Например, если память выделена для mutex, функцию инициализации mutex (mutex_init) необходимо выполнить только один раз, когда память впервые выделяется для mutex. Последующие распределения памяти не требуют выполнения инициализации, поскольку она уже имеет нужный статус от предыдущего освобождения и обращения к деконструктору.

### Функции API

Первый этап - создание структуры кэша slab, которую можно создать статически как:

```
struct struct kmem_cache *my_cachep;
struct kmem_cache *kmem_cache_create(const char *name, size_t size, size_t align, unsigned long flags, void (*ctor)(void*, struct kmem_cache *, unsigned long), void (*dtor)(void*, struct kmem_cache *, unsigned long));
```

Эта ссылка затем используется другими функциями кэша slab для создания, удаления, распределения и т.д. 

Структура `kmem_cache` содержит данные, относящиеся к конкретным CPU-модулям, набор настроек (доступных через файловую систему proc), статистических данных и элементов, необходимых для управления кэшем slab.

Функция ядра `kmem_cache_create()` используется для создания нового кэша. Обычно это происходит во время инициализации ядра или при первой загрузке модуля ядра. Его прототип определен как: 

* `name` — строка имени кэша;
* `size` — размер элементов кэша (единый и общий для всех элементов);
* `offset` — смещение первого элемента от начала кэша (для обеспечения соответствующего выравнивания по границам страниц, достаточно указать 0, что означает выравнивание по умолчанию);
* `flags` — опциональные параметры (может быть 0);
* `ctor`, `dtor` — конструктор и деструктор, соответственно, вызываются при размещении-освобождении каждого элемента, но с некоторыми ограничениями; например, деструктор будет вызываться (финализация), но не гарантируется, что это будет поисходить сразу непосредственно после удаления объекта.

Из флагов создания, поскольку они также находятся в постоянном изменении, и большая часть из них относится к отладочным опциям, стоит назвать:

* `SLAB_HWCACHE_ALIGN` — расположение каждого элемента в слабе должно выравниваться по строкам процессорного кэша, это может существенно поднять производительность, но непродуктивно расходуется память;

* `SLAB_POISON` — начально заполняет слаб предопределённым значением (A5A5A5A5) для обнаружения выборки неинициализированных значений;

Если не нужны какие-то особые изыски, то нулевое значение будет вполне уместно для параметра flags.

После того как кэш создан, ссылка на него возвращается функцией `kmem_cache_create`. Обратите внимание, что эта функция не выделяет память кешу. Вместо этого при попытке выделить объекты из кэша (изначально он пуст) ему выделяется память при помощи команды `refill`. Это та же команда, которая используется для добавления кэшу памяти, когда все его объекты израсходованы.
Как для любой операции выделения, ей сопутствует обратная операция по уничтожению слаба: 

```
int kmem_cache_destroy( kmem_cache_t *cache );
```

Операция уничтожения может быть успешна (здесь достаточно редкий случай, когда функция уничтожения возвращает значение результата), только если уже все объекты, полученные из кэша, были возвращены в него. Таким образом, модуль должен проверить статус, возвращённый `kmem_cache_destroy()`; ошибка указывает на какой-то вид утечки памяти в модуле (так как некоторые объекты не были возвращены).

После того, как кэш объектов создан, вы можете выделять объекты из него, вызывая функцию `kmem_cache_alloc()`. Вызывающий код передает кэш, из которого выделяется объект, и набор флагов:

```
void kmem_cache_free( kmem_cache_t *cache, const void *obj );
```

## Вопросы

* Как зарегистрировать файловую систему?

*Проинициализировать поля структуры `file_system_type` и передать ее в `register_filesystem`*

* Как смонтировать файловую систему?

1. Зарегистрировать mount в `file_system_type`
2. Дальше по коду: вызывается `mount_nodev` в нее передается `fill_super` (функция выполняющая основную работу). В ней инициализируются поля структуры суперблок и создается `inode`, инициализируются поля структуры `inode` и устанавливается поле `s_root` суперблока. Этот `inode` нужен для установки корневого каталога суперблока.

* Смонтировать ФС в две папки и показать.

```
/proc/mount (что она смонтирована 2 раза)
/proc/filesystems (что она зарегана)
lsmod (что она загружена и там 2 ссылки)
/proc/slabinfo показать слаб кэш
```

* Зачем слабы?

*Для повторного использования проинициализированных объектов. Побочный эффект - устранение фрагментации (за счет повторного использования проинициализированных объектов)*

* Где у нас в коде используется slab (кеш)?

*В module init*

* Когда у нас создаётся новый slab?

*Когда у нас заканчивается старый*

* Точки входа: `init`, `exit`, `mount`, `kill_superblock`
* Когда вызывается `mount`: при выполнении команды mount в консоле
* Когда вызывается `kill_superblock`: при выполнении команды umount в консоли

*Зачем нужна структура суперблок?*

* Описывает cмонтированную файловую систему