# Лабораторная работа №1

## Задание 1

Используя команду `mkdir`, cоздайте директорию (например, `mkdir iu7-54b`). Перейдите в созданную директорию с помощью команды `cd` (например, `cd iu7-54b`). Создайте поддиректорию (например, используя свою фамилию, `mkdir tskhovrebova`). 

#### Команда `ls`
Выводит список файлов.

```
tsyar@MacBook-Pro-Chovrebova iu7-54b % ls
tskhovrebova
```

- `-a` -- в том числе - скрытых.

```
tsyar@MacBook-Pro-Chovrebova iu7-54b % ls -a
.               ..              tskhovrebova
```

- `-l` -- в несколько столбцов с дополнительными данными.

```
tsyar@MacBook-Pro-Chovrebova iu7-54b % ls -l
total 0
drwxr-xr-x  2 tsyar  staff  64 23 сен 00:03 tskhovrebova
```

`d` | `rwx` | `r-x` | `r-x`_ -- тип файла и права доступа.
`2` -- количество жестких ссылок на файл.
`tsyar` -- владелец файла.
`staff` -- группа владельца.
`64` -- размер файла в байтах.
`23 сен 00:03` -- дата и время создания файла.
`tskhovrebova` -- имя файла.

Существует __7 типов файлов__:
1. `d` -- справочник или директория.
2. `-` -- обычный файл.
3. `l` -- символическая связь (канал) – символьная ссылка.
4. `b` -- специальный блочный файл - блочное устройство.
5. `c` -- специальный символьный файл - символьное устройство 
6. `p` -- программный канал (pipe)
7. `s` -- сокет в файловом пространстве имен (Домен – UNIX)

- `r` -- права на чтение.
- `w` -- права на запись.
- `x` -- права на выполнение.

Права доступа разделяются на __3 части__:
1. Следующие три символа -- __права доступа для владельца__ (в данном случае, `rwx`).
2. Следующие три символа -- __права доступа для группы__ (в данном случае, `r-x`).
3. Следующие три символа -- __права доступа для всех остальных__ (в данном случае, `r-x`).

- `-i` -- порядковый номер файла в файловой системе.

```
tsyar@MacBook-Pro-Chovrebova iu7-54b % ls -i
6240049 tskhovrebova
```

#### Команда `ps`

Просмотр информации о процессах, запущенных в системе.

- `-e` -- отображает информацию о всех процессах в системе, включая процессы, запущенные другими пользователями.

- `-a` -- отображает информацию о всех процессах, запущенных на терминале.

```
tsyar@MacBook-Pro-Chovrebova iu7-54b % ps -a
  PID TTY           TIME CMD
17384 ttys001    0:00.14 /bin/zsh -il
```
Где:
1. __PID__ (идентификатор процесса)
2. __TTY__ (терминал, на котором запущен процесс)
3. __TIME__ (время, затраченное процессом)
4. __CMD__ (команда, которая запустила процесс)
5. __PPID__(идентификатор родительского процесса)

- `-f` -- выводит информацию о процессах в более подробном виде.

```
  UID   PID  PPID   C STIME   TTY           TIME CMD
  501 17384 17377   0  1:41   ttys001    0:00.14 /bin/zsh -il
```

- `-x` -- отображает информацию о процессах, которые не имеют контролирующего терминала (например, демоны).

```
UID   PID  PPID   C STIME   TTY           TIME CMD
  501   384     1   0 пт02  ??         1:49.54 /usr/sbin/distnoted agent
```

- `-l` -- отображает подробную информацию о процессах, включая такие поля, как F (флаги), S (состояние), UID (идентификатор пользователя), C (приоритет), SZ (размер процесса в байтах), RSS (размер процесса в физической памяти).

```
UID   PID  PPID        F CPU PRI NI       SZ    RSS WCHAN     S             ADDR TTY           TIME CMD
  501 17384 17377     4006   0  31  0 33663028      8 -      Ss                  0 ttys001    0:00.14 /bin/zsh -il
```
- `-j` -- отображает информацию о процессах в формате, который включает в себя информацию о группах процессов (job control).

```
USER    PID  PPID  PGID   SESS JOBC STAT   TT       TIME COMMAND
tsyar 17384 17377 17384      0    0 Ss   s001    0:00.14 /bin/zsh -il
```

#### Статусы 

* `R` (running or runnable) -- __выполняется / может выполнятся__; система не различает -- выполняется процесс или стоит в очереди готовых на выполнение процессов; планировщику нужно поставить процесс в очередь, а диспетчер выделяет процессу квант процессорного времени.
* `S` (interruptble sleep) -- __прерываемый сон__; ожидание прерывающего события.
* `D` (uninterruptible sleep (usually IO)) -- __непрерываемый сон__; например, блокировку процесса в ожидании ввода/вывода прервать нельзя.=
* `T ` (terminate) -- __остановленный процесс__.
* `Z ` (zombie) -- статус процесса -- зомби, у кого отобраны все ресурсы, кроме последнего -- дескриптора (выделяется процессу при его создании), который содержит поле _state_, указатель на процесс -- предок, указатель на родственные процессы.

#### Флаги

* `0` -- был системный вызов `fork()`, был системный вызов `exec().

* `1` -- был системный вызов `fork()` (создает новый процесс -- потомок), но системного вызова `exec()` (переводит процесс на новое адресное пространство, что делается для запуска на выполнение новой программы, которая передается в качестве параметра) не было.

* `4` -- показывает, что процесс выполняется с правами __супер пользователя__.

__Супер пользователь__ -- процесс, который имеет доступ к функциям ядра, что позволяет ему выполнять любые действия в системе.

## Задание 2

Напишите программу, в которой создается дочерний процесс и организуйте как в предке, так и в потомке бесконечные циклы, в которых выводятся идентификаторы процессов с помощью системного вызова `getpid()`.

```
#include <stdio.h> 
#include <stdlib.h>
#include <unistd.h>

int main(void)
{
    int childpid;
    if ((childpid = fork()) == -1) {
        perror("Can't fork\n"); 
        exit(1);
    } else if (childpid == 0) {
        while(1) printf(" %d", getpid());
    } else {
        while(1) printf(" %d",getpid());
    }
    exit(0);
}
```
В случае успеха в родительском процессе возвращаемое значение -- PID дочернего процесса, а в дочернем -- 0.  В случае неудачи -1 -- в родительском процессе, а дочерний процесс не создается.

1. Запустите программу и посмотрите идентификаторы созданных процессов: предка и потомка.

2. Получите процесс -- зомби (с помощью команд `ps` и `kill`).

3. Получите осиротевший процесс (с помощью команд `ps` и `kill`).

Откроем два терминала: в одном -- запустим программу и получим следующий вывод; в другое введем команду `ps -al`.

