# Лабораторная работа №4

## Семафоры

Используются для управления доступом к разделяемым ресурсам и синхронизации выполнения группы процессов или потоков.

__Семафор Дейкстры__ - неотрицательная защищенная переменная (S), на которой были определены две неделимые операции: 

- P(S) - passeven (пропустить) - используется для захвата ресурса или блокировки доступа к нему.
1. Уменьшает значение семафора S на 1,
2. Если S = 0, процесс, выполняющий операцию P, блокируется в ожидании, пока S не станет положительным.

- V(S) - vregeven (освободить) - используется для освобождения ресурса или разблокировки ожидающих процессов.
1. Увеличивает значение семафора S на 1,
2. Если есть процессы, ожидающие освобождения S, один из них м.б. разблокирован.

__Бинарный семафор__ - на нем определены числа 0 и 1; семафор, принимающий значения 0 и 1.

__Считающий семафор__ - на нем определены целые положительные числа; семафор, принимающий неотрицательные значения.

#### Очередь к семафору

Когда семафор будет освобождён, его сможет захватить первый процесс из очереди.

##### Суть очереди

Если процесс не может захватить семафор, он блокируется, следовательно, нет активного ожидания (не расходуется проц. время). Другой процесс, который освободит семафор, разблокирует процесс, и он сможет захватить семафор.

__Активное ожидание__ - нерациональное расходование процессорного времени.

Так как блокировать / разблокировать процесс может только ОС, __плата - переход в режим ядра__, т.е. P(S) и V(S) - по сути системные вызовы. (Переключение контекста: аппаратный контекст при переходе в режим ядра; полный контекст, когда процесс блокируется).

#### Свойства наборов считающих семафоров

Одной неделимой операцией может быть изменено значение всех или части семафоров набора.

Таблицы семафоров содержат дескрипторы набора семафоров (у каждого набора семафоров в этой таблице есть дескриптор).

Семафоры поддерживаются таблицей ядра ОС.

#### О каждом наборе семафоров в системе имеется информация

1. Идентификатор - целое число, присваивается процессом, создавшим его. Другие процессы по этому идентификатору могут получить дескриптор и оперировать этим набором. Другой процесс может оперировать семафором.

2. UID создателя набора семафоров и ID его группы. Процесс, эффективный UID которого совпадает с UID создателя набора семафора, может удалять набор и изменять его управляющие параметры.

3. Права доступа: read, write, execute для user, group, others (для любого объекта системы).

4. Количество семафоров в наборе.

5. Время последнего изменения одного или нескольких значений семафоров процессом.

6. Время последнего изменения управляющих параметров набора каким-либо процессом.

7. Указатель на массив семафоров.
 

__Действительный ID пользователя__ - UID пользователя, породившего процесс.

__Эффективный ID пользователя__ - UID, использующийся при большинстве проверок прав доступа.

В большинстве случаев эффективный и действительный UID являются одним и тем же. Эффективный UID может отличаться от действительного при запуске, если установлен бит setuid файла исполняемой программы и файл не принадлежит пользователю, запускающему программу.

#### О каждом семафоре в системе имеется информация

1. Значение семафора.
2. ID процесса, оперировавшего семафором в последний раз.
3. Число заблокированных процессов на семафоре в текущий момент.

####  Системные вызовы, определенные на семафорах

1. semget() - создание набора семафоров;
2. semcontrol() - установка и изменение управляющих параметров семафора;
3. semop() - операция на семафоре; (вместо P(s) и V(s))

#### semop

1. sem_op < 0 - декремент (-1), захват семафора с блокировкой, если захват возможен.
2. sem_op = 0 - блокировка процесса в ожидании освобождения семафора (без захвата).
3) sem_op > 0 - инкремент (+1), освобождение семафора; если к семафору стоит очередь заблокированных на нем процессов, первый процесс в этой очереди будет разблокирован.

#### Флаги

- __IPC_NOWAIT__ - сообщает ядру о нежелании процесса переходить в состояние ожидания (освобождение семафора); (избежать блокировки всех процессов, которые находятся в очереди к ресурсу, который контролируется семафором. Если процесс, захвативший семафор (ресурс) аварийно завершится или получит сигнал kill (невозможно перехватить), то убиваемый процесс не сможет освободить семафор, и все процессы в очереди к семафору будут заблокированы навсегда.

- __SEM_UNDO__ - указывает ядру на необходимость отслеживать изменения значения семафора системным вызовом semop(), при этом значение имеет захват семафора. (При завершении процесса ядро ликвидирует сделанные процессом изменения значения семафора => для того, чтобы процессы не были заблокированы на семафоре навсегда).

## Задача «Производство - потребление»

Имеется буфер размером N и два типа процессов:
- __Производитель__: может производить и класть в буфер единицу данных, заполнять ячейки буфера.
- __Потребитель__: может только выбирать данные из буфера.

Решение на 3-х семафорах: 2 считающих и 1 бинарный
- se - empty (число пустых ячеек буфера);
- sf - full (число заполненных ячеек буфера);
- sb - binary;

Задача производства - потребления - задача, в которой не только осуществляется обеспечивается монопольный доступ к разделяемому ресурсу, который является буфер, но и реализуется синхронизация процессов.

__Producer__ ничего не сможет положить в буфер, если нет свободных ячеек (se = 0). На операции P(se) __Producer__ будет блокирован до тех пор, пока __Consumer__ не освободит ячейку буфера. Освободив ячейку буфера, __Consumer__ инкрементирует se.

Аналогично, __Consumer__ не сможет ничего взять из буфера, если буфер будет пуст. Он будет блокирован на sf до тех пор, пока __Producer__ не положит единицу данных в буфер. При этом он инкрементирует sf.

Процессы являются асинхронными, выполняются с собственной скоростью. Все зависит от того, кто получает квант.

Простое взаимоисключение само по себе не предполагает синхронизацию.

```S_IRWXU | S_IRWXG | S_IRWXO``` - это макрос, который определяет права доступа для создаваемых семафоров и разделяемой памяти. В данном контексте, это объединение следующих флагов:
- S_IRWXU: Права для владельца (User) - чтение, запись и выполнение.
- S_IRWXG: Права для группы (Group) - чтение, запись и выполнение.
- S_IRWXO: Права для остальных (Others) - чтение, запись и выполнение.

__!!!__ Доцерний процесс наследует обработчик сигналов.

## Задача «Читатели - писатели»

Два типа процессов: 

1. __Процессы - писатели__  могут изменять данные, поэтому они должны работать в режиме монопольного доступа к разделяемым данным. Если писатель изменяет данные, то к ним не может обратиться ни другой писатель, ни другой читатель.

2. __Процессы - читатели__ могут только читать данные. При этом могут читать параллельно, так как не мешают друг другу. 

`startread`: если есть активный писатель или в очереди есть ждущие писатели, то читатель блокируется на переменной типа «условие чтения». Если нет активного писателя и нет ждущих писателей в очереди, то количество активных читателей увеличивается и посылается сигнал «условие чтения». Тогда активизируются другие читатели в очереди ждущих читателей -> цепная реакция читателей: каждый новый активный читатель пробуждает следующих читателей в очереди.

Когда читатель завершает чтение, вызывая `stopread`, количество активных читателей уменьшается на 1. Когда количество активных читателей становится равным нулю - вызывается «можно писать».

`startwrite`: вызвав ее, писатель проверяет, есть ли активные читатели и активный писатель. Если есть, то писатель переходит в состояние ожидания. Если нет никого, то писатель захватывает логическую переменную, вход в критическую секцию.

`stopwrite`: сбрасывается переменная активного писателя. Если очереди читателей не пуста, посылается сигнал «можно читать», иначе посылается сигнал «можно писать».

Данные условия предотвращают бесконечное откладывание читателей и писателей. 

#### Потерянное обновление

```
Reader 4 read: 36 
Writer 1 write: 37 
Writer 2 write: 38 
Writer 3 write: 39 
Reader 3 read: 39 
Reader 1 read: 39 
Reader 2 read: 39 
Reader 4 read: 39 
Writer 1 write: 40
```

Writer 2 записал 38, Writer 3 записал 39, и Reader'ы читают 39.

Читатель может начать читать, если нет активного писателя и в очереди нет ждущих писателей. Поскольку читатель это проверяет перед чтением, возникает потерянное обновление. Эффект потерянного обновления: читатели не могут начать читать, если есть ждущие писатели. Это заложено в самом алгоритме и является его особенностью. 

#### Критическая секция читателей и писателей

В задаче "Читатели - писатели" критическая секция представляет собой участок кода, который выполняется только одним потоком одновременно. Это необходимо для предотвращения конфликтов и гонок данных между потоками, которые могут возникнуть при одновременном доступе к общим ресурсам.

Есть несколько читателей и писателей, которые имеют доступ к общему ресурсу (например, общему блоку памяти или файлу). Когда читатель или писатель хочет получить доступ к ресурсу, он должен войти в критическую секцию, чтобы гарантировать, что никакой другой процесс не изменит данные в то время, как он выполняет свою операцию.
Использование критической секции часто сопровождается использованием мьютексов (mutex) или других механизмов синхронизации, чтобы обеспечить атомарность операций и предотвратить возможность одновременного доступа нескольких процессов к общим данным.

Между двумя вызовами `semop`.

#### Характеризация задачи

Задача характеризуется наличием двух типов процессов:
1. процессы-читатели: могут только читать, могут работать параллельно
2. процессы-писатели: в режиме монопольного доступа к отдельному полю - разделяемой переменной, взаимоисключение обеспечивается бинарным семафором.

#### Что наследуют потомки от процесса-предка?

Сигнальную маску, адресное пространство, дескрипторы открытых файлов, маску режима создания файлов, обработчики сигналов, переменные окружения и маску режима создания файлов.

#### Почему порядок выполнения не в порядке номеров?

Случайные задержки. Процессы выходят из блокировки случайным образом и попадают в очередь готовых процессов, они стоят в очереди за квантом процессорного времени.
